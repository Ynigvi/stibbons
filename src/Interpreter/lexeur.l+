/*Define tokens */
%{
	#include <string>
	#include <cstdlib>
	#include "y.tab.h"
	using namespace std;
	
	#define YY_DECL yy::parser::token_type yylex (yy::parser::semantic_type* pyylval)
	YY_DECL;
	
	#define yyterminate() {}
%}

%option noyywrap
%option case-insensitive
 
/*Rules*/
%%
true|false {if(yytext[0] == 't' || yytext[0] == 'T') { pyylval->b = true; } else { pyylval->b = false; } return yy::parser::token::BOOLEAN;}

null {return yy::parser::token::NIL;}

fd|forward {return yy::parser::token::FD;}

lt|turn-left {return yy::parser::token::LT;}

rt|turn-right {return yy::parser::token::RT;}

pd|pen-down {return yy::parser::token::PD;}

pu|pen-up {return yy::parser::token::PU;}

die {return yy::parser::token::DIE;}

"==" {return yy::parser::token::EQ;}

"!=" {return yy::parser::token::NEQ;}

">" {return yy::parser::token::GT;}

">=" {return yy::parser::token::GEQ;}

"<" {return yy::parser::token::LS;}

"<=" {return yy::parser::token::LEQ;}

and|& {return yy::parser::token::AND;}

or|\| {return yy::parser::token::OR;}

xor|^ {return yy::parser::token::XOR;}

not|! {return yy::parser::token::NOT;}

[1-9]*\.?[0-9]+ {pyylval->d=atof(yytext); return yy::parser::token::NUMBER;}

(\"(\\\"|[^\"])*\")|('(\\'|[^'])*')|(\"\"\"(.|\\n)*\"\"\")  {pyylval->ps=new std::string(yytext); return yy::parser::token::STRING;}

#[a-fA-F0-9]{6}|red|blue|green|yellow|black|white|brown|purple|gray|orange|pink|magenta|cyan {pyylval->ps=new std::string(yytext); return yy::parser::token::COLOR;}

[_a-zA-Z][\-_a-zA-Z0-9]* {pyylval->ps=new std::string(yytext); return yy::parser::token::ID;}

"//"[^\n]*\n {}

"/*"([^*]|"*"+[^*/])*"*"+"/" ;

[ \t]* {}

.|\n {return yy::parser::token_type(yytext[0]);}

%%
/*Program*/

