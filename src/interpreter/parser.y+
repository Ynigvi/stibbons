%{
#include <iostream>
#include <exception>
#include <string>
#include <fstream>
#include "tree.h"
#include "../model/value.h"
#include "syntax-exception.h"

using namespace std;
%}

%skeleton "lalr1.cc"
%locations
%error-verbose

%code requires {
#include "tree.h"
#define YY_DECL yy::parser::token_type yylex (yy::parser::semantic_type* pyylval, yy::parser::location_type* loc)

#define YYSTYPE struct { stibbons::ValuePtr v; stibbons::TreePtr tr; }
}

%{
  YY_DECL;
%}
%token FD LT RT PU PD DIE AND OR XOR NOT EQ NEQ GT GEQ LS LEQ LB RB LP RP CALL RPT WHL END IF ELSE FCT NEW AGT ZONE
%token <v> NUMBER
%token <v> STRING
%token <v> COLOR
%token <v> BOOLEAN 
%token <v> NIL
%token <v> ID
%token <v> ZID
%type <tr> instr
%type <tr> instr_list
%type <tr> instr_turtle
%type <tr> bloc
%type <tr> expr
%type <tr> lit
%type <tr> affect
%type <tr> fct_call
%type <tr> statement
%type <tr> params
%type <tr> struc
%type <tr> loop
%type <tr> condi
%type <tr> creat
%type <tr> fct_decl
%type <tr> params_decl
%type <tr> breed_creat
%type <tr> agt_decl

%right '='
%left AND OR XOR 
%left EQ NEQ
%left GT GEQ LS LEQ
%left '+' '-'  
%left '*' '/' '%'
%right MOINSUNAIRE NOT
%nonassoc LB RB LP RP
%parse-param {stibbons::TreePtr t}
%%
code : instr_list {t->addSon($1);}
| '\n' instr_list {t->addSon($2);};

// General languages struct

instr_list : statement
{
  $$ = $1; 
}
| statement '\n' instr_list 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(0,nullptr);
  t1->addSon($1);
  try {
    t1->mergeTree($3);
  }
  catch(std::exception& e) {
    t1->addSon($3);
  }
  $$ = t1; 
}
| struc instr_list 
{ 
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(0,nullptr);
  t1->addSon($1);
  try {
    t1->mergeTree($2);
  }
  catch(std::exception& e) {
    t1->addSon($2);    
  }
  $$ = t1;
}
| { $$ = nullptr;};

statement : bloc { $$ = $1; }
| instr { $$ = $1; }
| statement '\n' { $$ = $1; }
; 

struc : condi { $$ = $1; }
| loop { $$ = $1; }
| creat { $$ = $1; }
| expr creat 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::RPT,nullptr);
  t1->addSon($1);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
}
| fct_decl { $$ = $1; }
| agt_decl { $$ = $1; }
| struc '\n' { $$ = $1; };

bloc : LB instr_list RB
{ 
  $$ = $2; 
}; 

instr : expr { $$ = $1; }
| instr_turtle { $$ = $1; } 
| breed_creat { $$ = $1; }
| expr breed_creat 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::RPT,nullptr);
  t1->addSon($1);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
};

// New agent

creat : NEW AGT statement 
{
  auto t1 = make_shared<stibbons::Tree>(yy::parser::token::NEW,nullptr);
  t1->addSon($3);
  $$ = t1;
};

breed_creat : NEW ID LP params RP
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::NEW,$2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  t1->appendSons($4);
  $$ = t1;
}
| NEW ID LP RP 
{
  auto t1 = make_shared<stibbons::Tree>(yy::parser::token::NEW,$2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
};

agt_decl : AGT ID LP params_decl RP statement
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::AGT,$2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  t1->addSon($6);
  t1->appendSons($4);
  $$ = t1;  
}
| AGT ID LP RP statement
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::AGT,$2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  t1->addSon($5);
  $$ = t1;  
};

// Turtle instructions

instr_turtle : FD expr
{ 
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::FD,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1; 
}
| LT expr
{ 
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::LT,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1; 
}
| RT expr
{ 
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::RT,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1; 
}
| PU
{ 
  $$ = make_shared<stibbons::Tree>(yy::parser::token::PU,nullptr);
}
| PD
{ 
  $$ = make_shared<stibbons::Tree>(yy::parser::token::PD,nullptr);
}
| DIE 
{ 
  $$ = make_shared<stibbons::Tree>(yy::parser::token::DIE,nullptr);
};

// Expressions

expr : LP expr RP { $$ = $2; }
| affect { $$ = $1; }
| lit { $$ = $1; }
| fct_call { $$ = $1; }
| ID { $$ = make_shared<stibbons::Tree>(yy::parser::token::ID,$1); }
| ZID { $$ = make_shared<stibbons::Tree>(yy::parser::token::ZID,$1); }
| '-' expr %prec MOINSUNAIRE 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('-',nullptr);
  t1->addSon($2);
  $$ = t1;
}
| NOT expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::NOT,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '+' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('+',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '*' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('*',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '-' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('-',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '/' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('/',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '%' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('%',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr AND expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::AND,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr OR expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::OR,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr XOR expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::XOR,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr EQ expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::EQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr NEQ expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::NEQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  $$ = t1;
}
| expr GT expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::GT,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr GEQ expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::GEQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr LS expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::LS,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr LEQ expr 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::LEQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
};

affect : ID '=' breed_creat
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('=',$1);
  t1->addSon($3);
  $$ = t1;
}
| ID '=' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>('=',$1);
  t1->addSon($3);
  $$ = t1;
}
| ZID '=' expr
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::ZONE,$1);
  t1->addSon($3);
  $$ = t1;
}; 

// Functions

fct_decl : FCT ID LP params_decl RP bloc
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::FCT,$2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  t1->addSon($6);
  t1->appendSons($4);
  $$ = t1;  
}
| FCT ID LP RP bloc
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::FCT,$2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  t1->addSon($5);
  $$ = t1;  
}
;

params_decl : params_decl ',' ID
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::FCT,nullptr);
  t1->appendSons($1);
  t1->addSon(make_shared<stibbons::Tree>(yy::parser::token::ID,$3));
  $$ = t1;
}
| ID
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::FCT,nullptr);
  t1->addSon(make_shared<stibbons::Tree>(yy::parser::token::ID,$1));
  $$ = t1;
};

fct_call : ID LP params RP 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::CALL,$1);
  t1->setPosition({@1.begin.line,@1.begin.column});
  t1->appendSons($3);
  $$ = t1;
}
| ID LP RP 
{
  auto t1 = make_shared<stibbons::Tree>(yy::parser::token::CALL,$1);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
};

params : params ',' expr 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::CALL,nullptr);
  t1->appendSons($1);
  t1->addSon($3);
  $$ = t1;
}
| expr 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::CALL,nullptr);
  t1->addSon($1);
  $$ = t1;
};

// Literals

lit : NUMBER { $$ = make_shared<stibbons::Tree>(yy::parser::token::NUMBER,$1); }
| STRING { $$ = make_shared<stibbons::Tree>(yy::parser::token::STRING,$1);}
| BOOLEAN { $$ = make_shared<stibbons::Tree>(yy::parser::token::BOOLEAN,$1);}
| COLOR { $$ = make_shared<stibbons::Tree>(yy::parser::token::COLOR,$1);}
| NIL { $$ = make_shared<stibbons::Tree>(yy::parser::token::NIL,$1);};

// Control struct

loop : RPT expr statement
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::RPT,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
}
| WHL expr statement
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::WHL,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
}
;

condi : IF expr statement 
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::IF,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->addSon(nullptr);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| IF expr statement ELSE statement
{
  stibbons::TreePtr t1 = make_shared<stibbons::Tree>(yy::parser::token::IF,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->addSon($5);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
;

%%

void yy::parser::error(const location& loc,string const& s) { 
  throw stibbons::SyntaxException(s.c_str(),loc.begin);
}
