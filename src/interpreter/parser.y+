%{
#include <iostream>
#include <exception>
#include <string>
#include <fstream>
#include "tree.h"
#include "../model/value.h"
#include "syntax-exception.h"

using namespace std;
%}

%skeleton "lalr1.cc"
%locations
%error-verbose

%code requires {
#include "tree.h"
#define YY_DECL yy::parser::token_type yylex (yy::parser::semantic_type* pyylval, yy::parser::location_type* loc)
}

%union{
  stibbons::Value* v;
  stibbons::Tree* tr;
}

%{
  YY_DECL;
%}
%token FD LT RT PU PD DIE AND OR XOR NOT EQ NEQ GT GEQ LS LEQ LB RB LP RP CALL RPT WHL END IF ELSE FCT NEW AGT
%token <v> NUMBER
%token <v> STRING
%token <v> COLOR
%token <v> BOOLEAN 
%token <v> NIL
%token <v> ID
%type <tr> instr
%type <tr> instr_list
%type <tr> instr_turtle
%type <tr> bloc
%type <tr> expr
%type <tr> lit
%type <tr> affect
%type <tr> fct_call
%type <tr> statement
%type <tr> params
%type <tr> struc
%type <tr> loop
%type <tr> condi
%type <tr> creat
%type <tr> fct_decl

%right '='
%left AND OR XOR 
%left EQ NEQ
%left GT GEQ LS LEQ
%left '+' '-'  
%left '*' '/' '%'
%right MOINSUNAIRE NOT
%nonassoc LB RB LP RP
%parse-param {stibbons::Tree* t}
%%
code : instr_list {t->addSon($1);}
| '\n' instr_list {t->addSon($2);};

// General languages struct

instr_list : statement
{
  $$ = $1; 
}
| statement '\n' instr_list 
{
  stibbons::Tree *t1 = new stibbons::Tree(0,nullptr);
  t1->addSon($1);
  try {
    t1->appendTree($3);
  }
  catch(std::exception& e) {
    t1->addSon($3);
  }
  $$ = t1; 
}
| struc instr_list 
{ 
  stibbons::Tree *t1 = new stibbons::Tree(0,nullptr);
  t1->addSon($1);
  try {
    t1->appendTree($2);
  }
  catch(std::exception& e) {
    t1->addSon($2);    
  }
  $$ = t1;
}
| { $$ = nullptr;};

statement : bloc { $$ = $1; }
| instr { $$ = $1; }
| statement '\n' { $$ = $1; }
; 

struc : condi { $$ = $1; }
| loop { $$ = $1; }
| creat { $$ = $1; }
| expr creat 
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::RPT,nullptr);
  t1->addSon($1);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
}
| fct_decl { $$ = $1; }
| struc '\n' { $$ = $1; };

bloc : LB instr_list RB
{ 
  $$ = $2; 
}; 

instr : expr { $$ = $1; }
| instr_turtle { $$ = $1; } ;

// New agent

creat : NEW AGT statement 
{
  auto t1 = new stibbons::Tree(yy::parser::token::NEW,nullptr);
  t1->addSon($3);
  $$ = t1;
};

// Turtle instructions

instr_turtle : FD expr
{ 
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::FD,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1; 
}
| LT expr
{ 
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::LT,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1; 
}
| RT expr
{ 
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::RT,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1; 
}
| PU
{ 
  $$ = new stibbons::Tree(yy::parser::token::PU,nullptr);
}
| PD
{ 
  $$ = new stibbons::Tree(yy::parser::token::PD,nullptr);
}
| DIE 
{ 
  $$ = new stibbons::Tree(yy::parser::token::DIE,nullptr);
};

// Expressions

expr : LP expr RP { $$ = $2; }
| affect { $$ = $1; }
| lit { $$ = $1; }
| fct_call { $$ = $1; }
| ID { $$ = new stibbons::Tree(yy::parser::token::ID,$1); }
| '-' expr %prec MOINSUNAIRE 
{
  stibbons::Tree *t1 = new stibbons::Tree('-',nullptr);
  t1->addSon($2);
  $$ = t1;
}
| NOT expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::NOT,nullptr);
  t1->addSon($2);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '+' expr
{
  stibbons::Tree *t1 = new stibbons::Tree('+',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '*' expr
{
  stibbons::Tree *t1 = new stibbons::Tree('*',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '-' expr
{
  stibbons::Tree *t1 = new stibbons::Tree('-',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '/' expr
{
  stibbons::Tree *t1 = new stibbons::Tree('/',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr '%' expr
{
  stibbons::Tree *t1 = new stibbons::Tree('%',nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr AND expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::AND,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr OR expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::OR,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr XOR expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::XOR,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr EQ expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::EQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr NEQ expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::NEQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  $$ = t1;
}
| expr GT expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::GT,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr GEQ expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::GEQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr LS expr
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::LS,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| expr LEQ expr 
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::LEQ,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
};

affect : ID '=' expr
{
  stibbons::Tree *t1 = new stibbons::Tree('=',$1);
  t1->addSon($3);
  $$ = t1;
}; 

// Functions

fct_decl : FCT ID LP RP bloc
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::FCT,$2);
  t1->addSon($5);
  $$ = t1;  
}
;

fct_call : ID LP params RP 
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::CALL,$1);
  t1->addSon($3);
  $$ = t1;
}
| ID LP RP {$$ = new stibbons::Tree(yy::parser::token::CALL,$1);};

params : params ',' expr 
{
  stibbons::Tree *t1 = new stibbons::Tree(0,nullptr);
  t1->addSon($1);
  t1->addSon($3);
  $$ = t1;
}
| expr { $$ = $1;};

// Literals

lit : NUMBER { $$ = new stibbons::Tree(yy::parser::token::NUMBER,$1); }
| STRING { $$ = new stibbons::Tree(yy::parser::token::STRING,$1);}
| BOOLEAN { $$ = new stibbons::Tree(yy::parser::token::BOOLEAN,$1);}
| COLOR { $$ = new stibbons::Tree(yy::parser::token::COLOR,$1);}
| NIL { $$ = new stibbons::Tree(yy::parser::token::NIL,$1);};

// Control struct

loop : RPT expr statement
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::RPT,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
}
| WHL expr statement
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::WHL,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;  
}
;

condi : IF expr statement 
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::IF,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->addSon(nullptr);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
| IF expr statement ELSE statement
{
  stibbons::Tree *t1 = new stibbons::Tree(yy::parser::token::IF,nullptr);
  t1->addSon($2);
  t1->addSon($3);
  t1->addSon($5);
  t1->setPosition({@1.begin.line,@1.begin.column});
  $$ = t1;
}
;

%%

void yy::parser::error(const location& loc,string const& s) {
  throw stibbons::SyntaxException(s.c_str(),loc.begin);
}
