%{
	#include <iostream>
	#include <exception>
	#include <string>
	using namespace std;
	
	#define YY_DECL yy::parser::token_type yylex (yy::parser::semantic_type* pyylval)
%}

%skeleton "lalr1.cc"
%union{
	//Values* v;
	bool b;
	double d;
	std::string* ps;
}

%{
	YY_DECL;
%}
%token FD LT RT PU PD DIE AND OR XOR NOT EQ NEQ GT GEQ LS LEQ LB RB LP RP
%token NUMBER
%token STRING
%token COLOR
%token BOOLEAN 
%token NIL
%token ID
%type <d> expr

%left '+' '-' '*' '/' '%' AND OR XOR EQ NEQ GT GEQ LS LEQ
%right MOINSUNAIRE NOT
%%
instr_list : instr instr_list 
           |bloc instr_list {}
           | {};
						 
bloc : LB instr_list instr_bloc RB {};
     
instr_bloc : expr {} 
           | instr_turtle {}
           | {};
	 
instr : expr '\n' {}
      | instr_turtle '\n' {};

instr_turtle : FD expr {}
             | LT expr {}
             | RT expr {}
             | PU {}
             | PD {}
             | DIE {};

expr : LP expr RP {}
     | affect {}
     | lit {}
     | fct_call {}
     | ID {}
     | '-' expr %prec MOINSUNAIRE {}
     | NOT expr {}
     | expr '+' expr {}
     | expr '*' expr {}
     | expr '-' expr {}
     | expr '/' expr {}
     | expr '%' expr {}
     | expr AND expr {}
     | expr OR expr {}
     | expr XOR expr {}
     | expr EQ expr {}
     | expr NEQ expr {}
     | expr GT expr {}
     | expr GEQ expr {}
     | expr LS expr {}
     | expr LEQ expr {};		
					
affect : ID '=' expr {}; 
					
fct_call : ID LP params RP {}
         | ID LP RP {};

params : params ',' expr  {}
       | expr {};
       
lit : NUMBER {}
    | STRING {}
    | BOOLEAN {}
    | COLOR {}
    | NIL {};
    
   
%%
void yy::parser::error(string const& s) {
	cout<<endl<<"Erreur : "<<s<<endl;
}

int main() {
	yy::parser* pparser = new yy::parser();
	int i=pparser->parse();
	
	return i;
}
